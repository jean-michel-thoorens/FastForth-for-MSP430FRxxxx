# Define SciTE settings for Forth files

# These patterns conflict with fortran.properties and nncrontab.properties
# so disable these other properties files if you want to use forth.
file.patterns.forth=*.f;*.4th

# add '*.tab;*.spf;' to 'source.files' variable in 'SciTEGlobal.properties'
# if you want to include these file patterns into default source file list

lexer.$(file.patterns.forth)=forth

*language.forth=Forth|forth||



filter.forth=Forth files (4th f)|$(file.patterns.forth)|

*filter.forth=$(filter.forth)


word.characters.$(file.patterns.forth)=$(chars.alpha)$(chars.numeric)_

comment.block.forth=\
#comment.block.at.line.start.forth=0
comment.stream.start.forth=(
comment.stream.end.forth=)
comment.box.start.forth=\
comment.box.middle.forth=\
comment.box.end.forth=\

# Forth styles

# control keywords Forth
keywords.$(file.patterns.forth)=\
again begin case do else endcase endof if loop +loop leave unloop of repeat then until  while ?do \
<  >  >= = <> 0<> 0= 0< <0 0>= u< u>= S< S>= jmp goto bw1 bw2 bw3 fw1 fw2 fw3

# Keywords
keywords2.$(file.patterns.forth)=\
dup ?dup drop rot swap over @ ! 2@ 2! 2dup 2drop 2swap 2over nip r@ >r r> 2r@ 2>r 2r> \
     sp@ sp! @ ! c@ c! s>d um/mod um* m* * fm/mod sm/rem rshift lshift invert 1+ 1- negate \
    (cr) (EMIT) (accept) (warm) is lit warm depth /mod mod \
    space spaces bl word char fill key? key  abort abort" */ 2* 2/ /mod cell+ cells char+ \
    chars move abs hex decimal hold <# # #s #> sign or \
    count type . u. dump (.") >number ' immediate exit recurse here allot , \
    c, branch 0branch  ?branch ." align aligned create does> \
    variable constant defer definitions forth forget only also previous literal \
    source evaluate word interpret quit >body execute find state base \
    immediate words  accept emit cr type echo noecho min max true false \
    char [char] postpone ['] rst_here rst_state wipe pwr_here  pwr_state ( .( \
    assembler

# defwords
keywords3.$(file.patterns.forth)=\
code endcode  :  ;  \
lo2hi hi2lo colon asm endasm \

# MSP430 assembly words & MSP430_instructions
keywords4.$(file.patterns.forth)=\
adc adc.b adc.w add add.b add.w addc addc.b addc.w and and.b and.w \
    bic bic.b bic.w bis bis.b bis.w bit bit.b bit.w br branch call clrc clrn clrz dint eint \
    clr clr.b clr.w cmp cmp.b cmp.w dadc dadc.b dadc.w dadd dadd.b dadd.w dec dec.b dec.w decd decd.b decd.w \
    inc inc.b inc.w incd incd.b incd.w inv inv.b inv.w mov mov.b mov.w pop pop.b pop.w push push.b push.w \
    jc jhs je jeq jz jge jl jmp jn jnc jlo jne jnz nop nop2 nop3 nop4 nop5 nop6 nop7 ret reti setc setn setz swpb sxt \
    rla rla.b rla.w rlc rlc.b rlc.w rra rra.b rra.w rrc rrc.b rrc.w sbc sbc.b sbc.w sub sub.b sub.w \
    subc subc.b subc.w sbb sbb.b sbb.w tst tst.b tst.w xor xor.b xor.w \
    pushm popm rlam rram rrcm rrum \


#keywords5.$(file.patterns.forth)= \
#u v w x y ip tos pc rsp psp

# string words
keywords6.$(file.patterns.forth)=\
s"  z" " ." c"





# Default
style.forth.32=$(font.base)

# whitespace (SCE_FORTH_DEFAULT)
style.forth.0=$(font.base)

# Comment (SCE_FORTH_COMMENT)
style.forth.1=fore:#00FF00,$(font.comment)

# ( ) comment (SCE_FORTH_COMMENT_ML)
style.forth.2=fore:#00FF00,$(font.comment)

# ML comment (SCE_FORTH_IDENTIFIER)
style.forth.3=fore:#FFFFFF

# control (keyword_FORTH_CONTROL)
style.forth.4=fore:#007f7F

# Keywords (keyword2_SCE_FORTH_KEYWORD)
style.forth.5=fore:#FF0FF,$(font.base)

# defwords (keyword3_SCE_FORTH_DEFWORD)
style.forth.6=fore:#FFFF00,$(font.base)

# preword1 (keyword4_SCE_msp430_assembly)
style.forth.7=fore:#FF0000,$(font.base)

# preword2 (keyword5_SCE_msp430_registers)
style.forth.8=fore:#FFFF00,$(font.base)

# number (SCE_FORTH_NUMBER)
style.forth.9=fore:#007F7F,$(font.base)

# Double quoted string (SCE_FORTH_STRING)
style.forth.10=fore:#00FFFF,$(font.base)

# locale
style.forth.11=fore:#0000CC,$(font.base)

#command.compile.*.f=spf.cmd $(FileNameExt)

command.name.0.*.f=preprocess file.f with 2:[target].pat then send file.4th to [target] with ECHO
command.0.*.f=*\config\scite\AS_MSP430\send_file.f_to_target.bat $(FileDir)\$(FileName).f $(2) ECHO

command.name.1.*.f=preprocess file.f with 2:[target].pat then send file.4th to [target] without ECHO
command.1.*.f=*\config\scite\AS_MSP430\send_file.f_to_target.bat $(FileDir)\$(FileName).f $(2) NOECHO

command.name.2.*.f=preprocess file.f with 2:[target].pat then send file.4th to [target] SD_CARD
command.2.*.f=*\config\scite\AS_MSP430\send_file.f_to_SD_CARD_target.bat $(FileDir)\$(FileName).f $(2)

command.name.3.*.f=preprocess file.f with 2:[target].pat to file.4th (for debug)
command.3.*.f=*\config\scite\AS_MSP430\convert_file.f_to_file.4th.bat $(FileDir)\$(FileName).f $(2)

command.name.4.*.f=convert FORTH registers to TI's ones
command.4.*.f=\prog\gema\gema -line -t -f \config\gema\FastForthREGtoTI.pat $(FileNameExt) $(FileNameExt)

command.name.5.*.f=convert TI registers to FORTH's ones
command.5.*.f=\prog\gema\gema -line -t -f \config\gema\TiREGtoFastForth.pat $(FileNameExt) $(FileNameExt)


command.name.0.*.4th=send file.4th to [target] with ECHO
command.0.*.4th=*\config\scite\AS_MSP430\send_file.4th_to_target.bat $(FileDir)\$(FileName).4th ECHO

command.name.1.*.4th=send file.4th to [target] without ECHO
command.1.*.4th=*\config\scite\AS_MSP430\send_file.4th_to_target.bat $(FileDir)\$(FileName).4th NOECHO

command.name.2.*.4th=send file.4th to [target] SD_CARD
command.2.*.4th=*\config\scite\AS_MSP430\send_file.4th_to_SD_CARD_target.bat $(FileDir)\$(FileName).4th

command.name.3.*.4th=convert TI registers to FORTH's ones
command.3.*.4th=*\prog\gema\gema -line -t -f \config\gema\TiREGtoFastForth.pat $(FileNameExt) $(FileNameExt)

command.name.4.*.4th=convert FORTH registers to TI's ones
command.4.*.4th=*\prog\gema\gema -line -t -f \config\gema\FastForthREGtoTI.pat $(FileNameExt) $(FileNameExt)

